#pragma newdecls required
#pragma semicolon 1

#include <sourcemod>
#include <colors>
#include <sdktools>
#include <sdkhooks>
#include <left4dhooks>

#define MAX(%0,%1) (((%0) > (%1)) ? (%0) : (%1))

#define STR_MAX_WEAPON_LEN 32

#define SHOTGUN_TIME       0.25
#define MELEE_TIME         0.25
#define POUNCE_TIMER       0.1

#define TEAM_SURVIVOR      2
#define TEAM_INFECTED      3

#define HITGROUP_HEAD      1

#define BREV_SI            1
#define BREV_CI            2
#define BREV_ACC           4
#define BREV_SKEET         8

#define BREV_MELEE         32
#define BREV_DMG           64

// zombie classes
#define ZC_SMOKER          1
#define ZC_BOOMER          2
#define ZC_HUNTER          3
#define ZC_SPITTER         4
#define ZC_JOCKEY          5
#define ZC_CHARGER         6
#define ZC_WITCH           7
#define ZC_TANK            8

// weapon types
#define WPTYPE_NONE        0
#define WPTYPE_SHELLS      1
#define WPTYPE_MELEE       2
#define WPTYPE_BULLETS     3

// weapons
#define WP_MELEE           19

#define WP_PISTOL          1
#define WP_PISTOL_MAGNUM   32

#define WP_SMG             2
#define WP_SMG_SILENCED    7

#define WP_HUNTING_RIFLE   6
#define WP_SNIPER_MILITARY 10

#define WP_PUMPSHOTGUN     3
#define WP_SHOTGUN_CHROME  8
#define WP_AUTOSHOTGUN     4
#define WP_SHOTGUN_SPAS    11

#define WP_RIFLE           5
#define WP_RIFLE_DESERT    9
#define WP_RIFLE_AK47      26

#define WP_MOLOTOV         13
#define WP_PIPE_BOMB       14
#define WP_VOMITJAR        25

#define WP_SMG_MP5         33
#define WP_RIFLE_SG552     34
#define WP_SNIPER_AWP      35
#define WP_SNIPER_SCOUT    36

#define WP_FIRST_AID_KIT   12
#define WP_PAIN_PILLS      15
#define WP_ADRENALINE      23
#define WP_MACHINEGUN      45

// damage type
#define DMG_GENERIC        0               // generic damage was done
#define DMG_CRUSH          (1 << 0)        // crushed by falling or moving object.
                                           // NOTE: It's assumed crush damage is occurring as a result of physics collision, so no extra physics force is generated by crush damage.
                                           // DON'T use DMG_CRUSH when damaging entities unless it's the result of a physics collision. You probably want DMG_CLUB instead.
#define DMG_BULLET         (1 << 1)        // shot
#define DMG_SLASH          (1 << 2)        // cut, clawed, stabbed
#define DMG_BURN           (1 << 3)        // heat burned
#define DMG_BLAST          (1 << 6)        // explosive blast damage
#define DMG_CLUB           (1 << 7)        // crowbar, punch, headbutt
#define DMG_BUCKSHOT       (1 << 29)       // not quite a bullet. Little, rounder, different.

/*
    Changelog
    ---------

        0.1f
            - fixed more error spam in error logs
        0.1e
            - fixed error spam in error logs
        0.1d
            - melee accuracy now hidden by default
            - built in some better safeguards against client index out of bounds probs
 */


public Plugin myinfo = {
    name        = "1v1 SkeetStats",
    author      = "Tabun",
    description = "Shows 1v1-relevant info at end of round.",
    version     = "0.1f",
    url         = "nope"
};

/*
    1       leave out Kill stats
    2       leave out CI stats
    4       leave out Accuracy stats
    8       leave out Skeet stats
    32      leave out Melee accuracy
    64      leave out Damage count
*/

char  g_szClientName      [MAXPLAYERS + 1][64]; // which name is connected to the clientId?

int   g_iGotKills         [MAXPLAYERS + 1];     // SI kills track for each client
int   g_iGotCommon        [MAXPLAYERS + 1];     // CI kills
int   g_iDidDamage        [MAXPLAYERS + 1];     // SI only these are a bit redundant, but will keep anyway for now
int   g_iDidDamageAll     [MAXPLAYERS + 1];     // SI + tank + witch
int   g_iDidDamageTank    [MAXPLAYERS + 1];     // tank only
int   g_iDidDamageWitch   [MAXPLAYERS + 1];     // witch only

int   g_iShotsFired       [MAXPLAYERS + 1];     // shots total
int   g_iPelletsFired     [MAXPLAYERS + 1];     // shotgun pellets total
int   g_iShotsHit         [MAXPLAYERS + 1];     // shots hit
int   g_iPelletsHit       [MAXPLAYERS + 1];     // shotgun pellets hit
int   g_iMeleesFired      [MAXPLAYERS + 1];     // melees total
int   g_iMeleesHit        [MAXPLAYERS + 1];     // melees hit

int   g_iDeadStops        [MAXPLAYERS + 1];     // all hunter deadstops (lunging hunters only)
int   g_iHuntSkeets       [MAXPLAYERS + 1];     // actual skeets (lunging hunter kills, full/normal)
int   g_iHuntSkeetsInj    [MAXPLAYERS + 1];     // injured skeets (< 150.0, on injured hunters)
int   g_iHuntHeadShots    [MAXPLAYERS + 1];     // all headshots on hunters (non-skeets too)

bool  g_bIsHurt           [MAXPLAYERS + 1];     // if a hunter player has been damaged (below 150)
bool  g_bIsPouncing       [MAXPLAYERS + 1];     // if a hunter player is currently pouncing
int   g_iDmgDuringPounce  [MAXPLAYERS + 1];     // how much total damage in a single pounce (cumulative)

float g_fPreviousShot     [MAXPLAYERS + 1];     // when was the previous shotgun blast? (to collect all hits for 1 shot)
int   g_iPreviousShotType [MAXPLAYERS + 1];     // weapon id for shotgun/melee that fired previous shot
int   g_bCurrentShotHit   [MAXPLAYERS + 1];     // whether we got a hit for the shot
int   g_iCurrentShotDmg   [MAXPLAYERS + 1];     // counting shotgun blast damage

bool  g_bCountTankDamage;
bool  g_bCountWitchDamage;

int   g_iBrevityFlags;
int   g_iPounceDmgInt;

int   g_iClientPlaying;                         // which clientId is the survivor this round?
bool  g_bLateLoad;
int   g_iRoundNumber;
bool  g_bInRound;
bool  g_bPlayerLeftSafeArea;                    // used for tracking FF when RUP enabled

bool  g_bNoHunterM2;

ConVar g_cvPounceDmgInt;     // skeet-damage per pounce
ConVar g_cvCountTankDamage;  // whether we're tracking tank damage
ConVar g_cvCountWitchDamage; // whether we're tracking witch damage
ConVar g_cvBrevityFlags;     // how verbose/brief the output should be:

/*
 *      ======
 *       init
 *      ======
 */

public APLRes AskPluginLoad2(Handle hPlugin, bool bLate, char[] szError, int iErrMax) {
    g_bLateLoad = bLate;
    return APLRes_Success;
}

public void OnPluginStart() {
    // Round triggers
    HookEvent("round_start",           Event_RoundStart,         EventHookMode_PostNoCopy);
    HookEvent("round_end",             Event_RoundEnd,           EventHookMode_PostNoCopy);
    HookEvent("player_left_safe_area", Event_PlayerLeftSafeArea, EventHookMode_PostNoCopy);

    // Catching data
    HookEvent("player_hurt",    Event_PlayerHurt);
    HookEvent("player_death",   Event_PlayerDeath);
    HookEvent("player_shoved",  Event_PlayerShoved);
    HookEvent("infected_hurt" , Event_InfectedHurt);
    HookEvent("infected_death", Event_InfectedDeath);

    HookEvent("weapon_fire",    Event_WeaponFire);
    HookEvent("ability_use",    Event_AbilityUse);

    // Cvars
    g_cvCountTankDamage = CreateConVar(
    "sm_skeetstat_counttank", "0",
    "Damage on tank counts towards totals if enabled.",
    0, true, 0.0, true, 1.0);
    g_bCountTankDamage = g_cvCountTankDamage.BoolValue;
    g_cvCountTankDamage.AddChangeHook(ConVarChange_CountTankDamage);

    g_cvCountWitchDamage = CreateConVar(
    "sm_skeetstat_countwitch", "0",
    "Damage on witch counts towards totals if enabled.",
    0, true, 0.0, true, 1.0);
    g_bCountWitchDamage = g_cvCountWitchDamage.BoolValue;
    g_cvCountWitchDamage.AddChangeHook(ConVarChange_CountWitchDamage);

    g_cvBrevityFlags = CreateConVar(
    "sm_skeetstat_brevity", "32",
    "Flags for setting brevity of the report (hide 1:SI, 2:CI, 4:Accuracy, 8:Skeets/Deadstops, 32: melee acc, 64: damage count).",
    0, true, 0.0);
    g_iBrevityFlags = g_cvBrevityFlags.IntValue;
    g_cvBrevityFlags.AddChangeHook(ConVarChange_BrevityFlags);

    g_cvPounceDmgInt = FindConVar("z_pounce_damage_interrupt");
    g_iPounceDmgInt = g_cvPounceDmgInt.IntValue;
    g_cvPounceDmgInt.AddChangeHook(ConVarChange_PounceDmgInt);

    g_bPlayerLeftSafeArea = false;

    // Commands
    RegConsoleCmd("sm_skeets", Cmd_SkeetStat, "Prints the current skeetstats.");
    RegConsoleCmd("sm_mvp",    Cmd_SkeetStat, "Prints the current skeetstats.");

    // late loading
    if (g_bLateLoad) {
        g_bPlayerLeftSafeArea = true;                 // assume they left it
        g_iClientPlaying      = GetCurrentSurvivor(); // find survivor again
    }
}

public void OnAllPluginsLoaded() {
    g_bNoHunterM2 = LibraryExists("l4d2_no_hunter_m2");
}

public void OnLibraryRemoved(const char[] szName) {
    if (strcmp(szName, "l4d2_no_hunter_m2") == 0)
        g_bNoHunterM2 = false;
}

public void OnLibraryAdded(const char[] szName) {
    if (strcmp(szName, "l4d2_no_hunter_m2") == 0)
        g_bNoHunterM2 = true;
}

public void OnClientPutInServer(int iClient) {
    char szTmpBuffer[64];
    GetClientName(iClient, szTmpBuffer, sizeof(szTmpBuffer));
    // if previously stored name for same client is not the same, delete stats & overwrite name
    if (strcmp(szTmpBuffer, g_szClientName[iClient], true) != 0) {
        ClearClientSkeetStats(iClient);
        strcopy(g_szClientName[iClient], sizeof(szTmpBuffer), szTmpBuffer);
    }
}

/*
 *      ========================================
 *       convar changes  (phase this out later)
 *      ========================================
 */

void ConVarChange_CountTankDamage(ConVar cv, const char[] szOldValue, const char[] szNewValue) {
    g_bCountTankDamage = g_cvCountTankDamage.BoolValue;
}

void ConVarChange_CountWitchDamage(ConVar cv, const char[] szOldValue, const char[] szNewValue) {
    g_bCountWitchDamage = g_cvCountWitchDamage.BoolValue;
}

void ConVarChange_BrevityFlags(ConVar cv, const char[] szOldValue, const char[] szNewValue) {
    g_iBrevityFlags = StringToInt(szNewValue);
}

void ConVarChange_PounceDmgInt(ConVar cv, const char[] szOldValue, const char[] szNewValue) {
    g_iPounceDmgInt = StringToInt(szNewValue);
}

/*
 *      ============================
 *       map load / round start/end
 *      ============================
 */

public void OnMapStart() {
    if (!g_bLateLoad)
        g_bPlayerLeftSafeArea = false;
    g_bLateLoad = false;
}

public void OnMapEnd() {
    g_iRoundNumber = 0;
    g_bInRound     = false;
}

void Event_RoundStart(Event eEvent, const char[] szName, bool bDontBroadcast) {
    g_bPlayerLeftSafeArea = false;
    if (!g_bInRound) {
        g_bInRound = true;
        g_iRoundNumber++;
    }
    // clear mvp stats
    for (int i = 1; i <= MaxClients; i++) {
        ClearClientSkeetStats(i);
    }
}

void Event_RoundEnd(Event eEvent, const char[] szName, bool bDontBroadcast) {
    // only show / log stuff when the round is done "the first time"
    if (g_bInRound) {
        ResolveOpenShots();
        CreateTimer(3.0, Timer_SkeetStatPrint, _, TIMER_FLAG_NO_MAPCHANGE);
        g_bInRound = false;
    }
}

void Event_PlayerLeftSafeArea(Event eEvent, const char[] szName, bool bDontBroadcast) {
    g_iClientPlaying = GetCurrentSurvivor();
    g_bPlayerLeftSafeArea = true;
}

/*
 *      ================
 *       cmds / reports
 *      ================
 */

Action Cmd_SkeetStat(int iClient, int iArgs) {
    if (g_bPlayerLeftSafeArea) {
        ResolveOpenShots();
        PrintSkeetStats(iClient);
    }
    return Plugin_Handled;
}

Action Timer_SkeetStatPrint(Handle hTimer) {
    PrintSkeetStats(0);
    return Plugin_Stop;
}

/*
 *      ===============================
 *       track damage/kills & accuracy
 *      ===============================
 */

void Event_PlayerHurt(Event eEvent, const char[] szName, bool bDontBroadcast) {
    int iZombieClass = 0;
    int iVictim      = GetClientOfUserId(eEvent.GetInt("userid"));
    int iAttacker    = GetClientOfUserId(eEvent.GetInt("attacker"));

    if (iAttacker != g_iClientPlaying)
        return;

    if (GetClientTeam(iVictim) != TEAM_INFECTED)
        return;

    int iDamage     = eEvent.GetInt("dmg_health");
    int iDamageType = eEvent.GetInt("type");
    int iHitGroup   = eEvent.GetInt("hitgroup");

    // accuracy track
    if (iDamageType & DMG_BUCKSHOT) {
        // shotgun
        // this is still part of the (previous) shotgun blast
        g_iCurrentShotDmg[g_iClientPlaying] += iDamage;
        // are we skeeting hunters?
        if (g_bIsPouncing[iVictim])
            g_iDmgDuringPounce[iVictim] += iDamage;

        if (!g_bCurrentShotHit[g_iClientPlaying]) {
            if (iHitGroup == HITGROUP_HEAD)
                g_iHuntHeadShots[g_iClientPlaying]++;
        }
        g_bCurrentShotHit[g_iClientPlaying] = true;
    } else if (iDamageType & DMG_BULLET) {
        // for bullets, simply count all hits
        g_iShotsHit[g_iClientPlaying]++;
        if (iHitGroup == HITGROUP_HEAD)
            g_iHuntHeadShots[g_iClientPlaying]++;

        // are we skeeting hunters?
        if (g_bIsPouncing[iVictim])
            g_iDmgDuringPounce[iVictim] += iDamage;
    } else if (iDamageType & DMG_SLASH || iDamageType & DMG_CLUB) {
        // for melees, like shotgun (multiple hits for one, so just count once)
        if (g_iPreviousShotType[g_iClientPlaying] == WP_MELEE && (GetGameTime() - g_fPreviousShot[g_iClientPlaying]) < MELEE_TIME)
            g_bCurrentShotHit[g_iClientPlaying] = true;
    }

    // track damage

    // survivor on zombie action
    iZombieClass = GetEntProp(iVictim, Prop_Send, "m_zombieClass");
    // separately store SI and tank damage
    if (iZombieClass >= ZC_SMOKER && iZombieClass < ZC_WITCH) {
        g_iDidDamage    [iAttacker] += iDamage;
        g_iDidDamageAll [iAttacker] += iDamage;
    } else if (iZombieClass == ZC_TANK && g_bCountTankDamage) {
        g_iDidDamageAll  [iAttacker] += iDamage;
        g_iDidDamageTank [iAttacker] += iDamage;
    }
}

void Event_InfectedHurt(Event eEvent, const char[] szName, bool bDontBroadcast) {
    // check user
    int iAttacker = GetClientOfUserId(eEvent.GetInt("attacker"));
    if (iAttacker != g_iClientPlaying)
        return;

    // check if round started
    if (!g_bPlayerLeftSafeArea)
        return;

    int iDamage      = eEvent.GetInt("amount");
    int iDamageType  = eEvent.GetInt("type");
    int iVictimEntId = eEvent.GetInt("entityid");

    // accuracy track

    // shotgun
    if (iDamageType & DMG_BUCKSHOT) {
        // this is still part of the (previous) shotgun blast
        g_bCurrentShotHit[g_iClientPlaying] = true;
        if (IsCommonInfected(iVictimEntId)) {
            switch (g_iPreviousShotType[g_iClientPlaying]) {
                case WP_PUMPSHOTGUN: {
                    iDamage = RoundFloat(float(iDamage) * 2.03);
                }
                case WP_SHOTGUN_CHROME: {
                    iDamage = RoundFloat(float(iDamage) * 1.64);
                }
                case WP_AUTOSHOTGUN: {
                    iDamage = RoundFloat(float(iDamage) * 2.29);
                }
                case WP_SHOTGUN_SPAS: {
                    iDamage = RoundFloat(float(iDamage) * 1.84);
                }
            }
        } else if (IsWitch(iVictimEntId)) {
            int iDamageDone = iDamage;
            // event called per pellet
            switch (g_iPreviousShotType[g_iClientPlaying]) {
                case WP_PUMPSHOTGUN: {
                    iDamage = 25;
                }
                case WP_SHOTGUN_CHROME: {
                    iDamage = 31;
                }
                case WP_AUTOSHOTGUN: {
                    iDamage = 23;
                }
                case WP_SHOTGUN_SPAS: {
                    iDamage = 28;
                }
            }

            // also note that crowns do 1 pellet damage less than actual, for some reason, so add it:
            //          each pellet doing > 100 means close enough to the crown
            if (g_iCurrentShotDmg[g_iClientPlaying] + iDamage > 200 && iDamageDone > 100)
                iDamage = iDamage * 2;
        }
        g_iCurrentShotDmg[g_iClientPlaying] += iDamage;
    } else if (iDamageType & DMG_BULLET) {
        // for bullets, simply count all hits
        g_iShotsHit[g_iClientPlaying]++;
    } else if (iDamageType & DMG_SLASH || iDamageType & DMG_CLUB) {
        // for melees, like shotgun (multiple hits for one, so just count once)
        if (g_iPreviousShotType[g_iClientPlaying] == WP_MELEE && (GetGameTime() - g_fPreviousShot[g_iClientPlaying]) < MELEE_TIME)
            g_bCurrentShotHit[g_iClientPlaying] = true;
    }

    // witch (damage)
    if (IsWitch(iVictimEntId)) {
        int iDamageDone = eEvent.GetInt("amount");
        // no world damage or flukes or whatevs, no bot attackers
        if (g_bCountWitchDamage) {
            g_iDidDamageAll   [iAttacker] += iDamageDone;
            g_iDidDamageWitch [iAttacker] += iDamageDone;
        }
    }
}

void Event_PlayerDeath(Event eEvent, const char[] szName, bool bDontBroadcast) {
    int iZombieClass = 0;
    int iVictim      = GetClientOfUserId(eEvent.GetInt("userid"));
    int iAttacker    = GetClientOfUserId(eEvent.GetInt("attacker"));

    if (iAttacker != g_iClientPlaying)
        return;

    if (!IsClientAndInGame(iVictim))
        return;

    if (GetClientTeam(iVictim) != TEAM_INFECTED)
        return;

    int iDamageType = eEvent.GetInt("type");
    // skeet check
    if (iDamageType & DMG_BUCKSHOT || iDamageType & DMG_BULLET) {
        // shotgun
        // did we skeet a hunter?
        if (g_bIsPouncing[iVictim]) {
            if (g_bIsHurt[iVictim]) {
                g_iHuntSkeetsInj[g_iClientPlaying]++;
            } else {
                g_iHuntSkeets[g_iClientPlaying]++;
            }
            g_bIsPouncing      [iVictim] = false;
            g_iDmgDuringPounce [iVictim] = 0;
        }
    }

    // kill-count
    iZombieClass = GetEntProp(iVictim, Prop_Send, "m_zombieClass");
    // only SI, not the tank && only player-attackers
    if (iZombieClass >= ZC_SMOKER && iZombieClass < ZC_WITCH) {
        // store kill to count for attacker id
        g_iGotKills[iAttacker]++;
        if (iZombieClass == ZC_HUNTER)
        {
            // check if we just skeeted this
        }
    }
}

void Event_InfectedDeath(Event eEvent, const char[] szName, bool bDontBroadcast) {
    int iAttacker = GetClientOfUserId(eEvent.GetInt("attacker"));
    if (IsClientAndInGame(iAttacker)) {
        if ((GetClientTeam(iAttacker) == TEAM_SURVIVOR))
            g_iGotCommon[iAttacker]++;
    }
}

void Event_PlayerShoved(Event eEvent, const char[] szName, bool bDontBroadcast) {
    // check user
    int iAttacker = GetClientOfUserId(eEvent.GetInt("attacker"));
    if (iAttacker != g_iClientPlaying)
        return;

    // get hunter player
    int iVictim = GetClientOfUserId(eEvent.GetInt("userId"));
    if (g_bIsPouncing[iVictim]) {
        g_iDeadStops       [iAttacker]++;
        g_bIsPouncing      [iVictim] = false;
        g_iDmgDuringPounce [iVictim] = 0;
    }
}

// hunters pouncing / tracking
void Event_AbilityUse(Event eEvent, const char[] szName, bool bDontBroadcast) {
    // track hunters pouncing
    int iClient = GetClientOfUserId(eEvent.GetInt("userid"));

    char szAbilityName[64];
    eEvent.GetString("ability", szAbilityName, sizeof(szAbilityName));

    if (IsClientAndInGame(iClient) && strcmp(szAbilityName, "ability_lunge", false) == 0 && !g_bIsPouncing[iClient]) {
        // Hunter pounce
        g_bIsPouncing      [iClient] = true;
        g_iDmgDuringPounce [iClient] = 0;
        g_bIsHurt          [iClient] = (GetClientHealth(iClient) < g_iPounceDmgInt);
        CreateTimer(POUNCE_TIMER, Timer_GroundTouch, GetClientUserId(iClient), TIMER_REPEAT|TIMER_FLAG_NO_MAPCHANGE);
    }
}

Action Timer_GroundTouch(Handle hTimer, any iUserId) {
    int iClient = GetClientOfUserId(iUserId);
    if (!IsClientAndInGame(iClient))
        return Plugin_Stop;
    if (IsGrounded(iClient) || !IsPlayerAlive(iClient)) {
        // Reached the ground or died in mid-air
        g_bIsPouncing[iClient] = false;
        return Plugin_Stop;
    }
    return Plugin_Continue;
}

bool IsGrounded(int iClient) {
    return (GetEntProp(iClient,Prop_Data,"m_fFlags") & FL_ONGROUND) > 0;
}

// accuracy:
void Event_WeaponFire(Event eEvent, const char[] szName, bool bDontBroadcast) {
    // check user
    int iClient = GetClientOfUserId(eEvent.GetInt("userid"));
    if (iClient != g_iClientPlaying)
        return;

    // check if round started
    if (!g_bPlayerLeftSafeArea)
        return;

    int iWeaponId = eEvent.GetInt("weaponid");
    int iCount    = eEvent.GetInt("count");

    // differentiate between weapon types
    int iWeaponType = GetWeaponType(iWeaponId);

    // 1. shotgun blasts (keep track of pellets, separate shot accuracy from pellet accuracy
    if (iWeaponType == WPTYPE_SHELLS) {
        // handle previous shot, if any open
        ResolveOpenShots();
        // open new shot
        g_iShotsFired       [g_iClientPlaying]++;
        g_iPelletsFired     [g_iClientPlaying] += iCount;
        g_fPreviousShot     [g_iClientPlaying] = GetGameTime();        // track shot from this time
        g_bCurrentShotHit   [g_iClientPlaying] = false;                // so we can check just 1 hit for the shot
        g_iCurrentShotDmg   [g_iClientPlaying] = 0;                    // reset, count damage for this shot
        g_iPreviousShotType [g_iClientPlaying] = iWeaponId;            // so we know what kind of shotgun blast it was
        return;
    }
    // 2. melee
    if (iWeaponType == WPTYPE_MELEE) {
        // handle previous shot, if any open
        ResolveOpenShots();

        g_iMeleesFired      [g_iClientPlaying]++;
        g_fPreviousShot     [g_iClientPlaying] = GetGameTime();        // track shot from this time
        g_bCurrentShotHit   [g_iClientPlaying] = false;                // so we can check just 1 hit for the swing
        g_iCurrentShotDmg   [g_iClientPlaying] = 0;                    // reset, count damage for this shot
        g_iPreviousShotType [g_iClientPlaying] = WP_MELEE;             // so we know a melee is 'out'
        return;
    }
    // 3. rifles / snipers / pistols (per shot accuracy)
    if (iWeaponType == WPTYPE_BULLETS) {
        g_iShotsFired[g_iClientPlaying]++;
        return;
    }
    // 4. weird cases: pain pills / medkits
    // not relevant, ignore for now
}

/*
 *      =============
 *       Stat string
 *      =============
 */

void PrintSkeetStats(int iClient) {
    char szPrintBuffer[512];
    char szTmpBuffer[256];

    szPrintBuffer = "";

    if (g_iClientPlaying <= 0)
        return;

    // no need to calculate, show stats
    //  1. SI damage & SI kills
    //  2. skeets
    //  3. accuracy
    //  4. common kills

    /*
        TODO: make it so:
        {blue}[{default}1v1Stats{blue}]{default} - Kills: (934 Dmg, 4 Kills) (23 Common)
        {blue}[{default}1v1Stats{blue}]{default} - Skeet: (1 Normal, 3 Injured) (5 Deadstops)
        {blue}[{default}1v1Stats{blue}]{default} - Acc. : (Total [72%], Per Pellet [25%]) (3 Headshots)
    */

    // report
    // 1 and 4
    if (!(g_iBrevityFlags & BREV_SI)) {
        if (!(g_iBrevityFlags & BREV_DMG)) {
            if (!(g_iBrevityFlags & BREV_CI)) {
                Format(szTmpBuffer, sizeof(szTmpBuffer), "{blue}[{default}1v1Stats{blue}] {green}Kills{default}: {blue}({default}%d{olive} dmg{default}, {default}%d {olive}kills{default}, {olive}commons{default}: %d{blue}){default}\n", g_iDidDamageAll[g_iClientPlaying], g_iGotKills[g_iClientPlaying], g_iGotCommon[g_iClientPlaying]);
            } else {
                Format(szTmpBuffer, sizeof(szTmpBuffer), "{blue}[{default}1v1Stats{blue}] {green}Kills{default}: {blue}({default}%d{olive} dmg{default}, {default}%d {olive}kills{blue}){default}\n", g_iDidDamageAll[g_iClientPlaying], g_iGotKills[g_iClientPlaying]);
            }
        } else {
            if (!(g_iBrevityFlags & BREV_CI)) {
                Format(szTmpBuffer, sizeof(szTmpBuffer), "{blue}[{default}1v1Stats{blue}] {green}Kills{default}: {blue}({default}%d {olive}kills{default}, {olive}commons{default}: %d{blue}){default}\n", g_iGotKills[g_iClientPlaying], g_iGotCommon[g_iClientPlaying]);
            } else {
                Format(szTmpBuffer, sizeof(szTmpBuffer), "{blue}[{default}1v1Stats{blue}] {green}Kills{default}: {blue}({default}%d {olive}kills{blue}){default}\n", g_iGotKills[g_iClientPlaying]);
            }
        }
        StrCat(szPrintBuffer, sizeof(szPrintBuffer), szTmpBuffer);
        if (!iClient) {
            CPrintToChatAll("%s", szPrintBuffer);
        } else if (IsClientAndInGame(iClient)) {
            CPrintToChat(iClient, "%s", szPrintBuffer);
        }
        szPrintBuffer = "";
    }
    // 2
    if (!(g_iBrevityFlags & BREV_SKEET)) {
        if (HunterShovingIsBlocked()) {
            Format(szTmpBuffer, sizeof(szTmpBuffer), "{blue}[{default}1v1Stats{blue}] {green}Skeets{default}: {blue}({olive}normal{default}: %d, {olive}hurt{default}: %d{blue}){default}\n", g_iHuntSkeets[g_iClientPlaying], g_iHuntSkeetsInj[g_iClientPlaying]);
        } else {
            Format(szTmpBuffer, sizeof(szTmpBuffer), "{blue}[{default}1v1Stats{blue}] {green}Skeets{default}: {blue}({olive}normal{default}: %d, {olive}hurt{default}: %d{blue}) ({olive}deadstops{default}: %d{blue}){default}\n", g_iHuntSkeets[g_iClientPlaying], g_iHuntSkeetsInj[g_iClientPlaying], g_iDeadStops[g_iClientPlaying]);
        }
        StrCat(szPrintBuffer, sizeof(szPrintBuffer), szTmpBuffer);
        if (!iClient) {
            CPrintToChatAll("%s", szPrintBuffer);
        } else if (IsClientAndInGame(iClient)) {
            CPrintToChat(iClient, "%s", szPrintBuffer);
        }
        szPrintBuffer = "";
    }
    // 3
    if (!(g_iBrevityFlags & BREV_ACC)) {
        if (g_iShotsFired[g_iClientPlaying] || (g_iMeleesFired[g_iClientPlaying] && !(g_iBrevityFlags & BREV_MELEE))) {
            if (g_iShotsFired[g_iClientPlaying]) {
                Format(szTmpBuffer, sizeof(szTmpBuffer), "{blue}[{default}1v1Stats{blue}] {green}Acc.{default} : {blue}({olive}all shots {blue}[{default}%.0f%%{blue}]{default}", float(g_iShotsHit[g_iClientPlaying]) / float(g_iShotsFired[g_iClientPlaying]) * 100);
            } else {
                Format(szTmpBuffer, sizeof(szTmpBuffer), "{blue}[{default}1v1Stats{blue}] {green}Acc.{default} : {blue}({olive}all shots {blue}[{default}%.0f%%{blue}]{default}", 0.0);
            }
            if (g_iPelletsFired[g_iClientPlaying]) {
                StrCat(szPrintBuffer, sizeof(szPrintBuffer), szTmpBuffer);
                Format(szTmpBuffer, sizeof(szTmpBuffer), ", {olive}buckshot {blue}[{default}%.0f%%{blue}]{default}", float(g_iPelletsHit[g_iClientPlaying]) / float(g_iPelletsFired[g_iClientPlaying]) * 100);
            }
            if (g_iMeleesFired[g_iClientPlaying] && !(g_iBrevityFlags & BREV_MELEE)) {
                StrCat(szPrintBuffer, sizeof(szPrintBuffer), szTmpBuffer);
                Format(szTmpBuffer, sizeof(szTmpBuffer), ", {olive}melee {blue}[{default}%.0f%%{blue}]{default}", float(g_iMeleesHit[g_iClientPlaying]) / float(g_iMeleesFired[g_iClientPlaying]) * 100);
            }
            StrCat(szPrintBuffer, sizeof(szPrintBuffer), szTmpBuffer);
            Format(szTmpBuffer, sizeof(szTmpBuffer), "{blue}){default}\n");
        } else {
            Format(szTmpBuffer, sizeof(szTmpBuffer), "{blue}[{default}1v1Stats{blue}] {green}Acc.{default} : {blue}({default}no shots fired{blue}){default}\n");
        }
        StrCat(szPrintBuffer, sizeof(szPrintBuffer), szTmpBuffer);
        if (!iClient) {
            CPrintToChatAll("%s", szPrintBuffer);
        } else if (IsClientAndInGame(iClient)) {
            CPrintToChat(iClient, "%s", szPrintBuffer);
        }
        szPrintBuffer = "";
    }
}

/*
 *      ===================
 *       general functions
 *      ===================
 */

// resolve hits, for the final shotgun blasts before wipe/saferoom
void ResolveOpenShots() {
    if (g_iClientPlaying <= 0)
        return;
    // if there's any shotgun blast not 'closed', close it
    if (g_iPreviousShotType[g_iClientPlaying]) {
        if (g_bCurrentShotHit[g_iClientPlaying]) {
            if (g_iPreviousShotType[g_iClientPlaying] == WP_MELEE) {
                // melee hit
                g_iMeleesHit[g_iClientPlaying]++;
            } else {
                // shotgun hit
                g_iShotsHit[g_iClientPlaying]++;
                // base hit pellets on amount of damage done
                // based on weaponId differences aswell since shotties do different amounts of damage
                // what to do about damage dropoff? ignore?
                if (g_iCurrentShotDmg[g_iClientPlaying]) {
                    int iTotalPellets;
                    int iPelletDamage;
                    switch (g_iPreviousShotType[g_iClientPlaying]) {
                        case WP_PUMPSHOTGUN: {
                            iTotalPellets = 10;
                            iPelletDamage = 25;
                        }
                        case WP_SHOTGUN_CHROME: {
                            iTotalPellets = 8;
                            iPelletDamage = 31;
                        }
                        case WP_AUTOSHOTGUN: {
                            iTotalPellets = 11;
                            iPelletDamage = 23;
                        }
                        case WP_SHOTGUN_SPAS: {
                            iTotalPellets = 9;
                            iPelletDamage = 28;
                        }
                    }
                    if (iTotalPellets) {
                        int iAddPellets = RoundFloat(float(g_iCurrentShotDmg[g_iClientPlaying] / iPelletDamage));
                        g_iPelletsHit[g_iClientPlaying] += (iAddPellets <= iTotalPellets) ? iAddPellets : iTotalPellets;
                    }
                }
            }
        }
        g_iPreviousShotType[g_iClientPlaying] = 0;
    }
}

// get type of weapon fired, diff between shotgun, melee and bullets
stock int GetWeaponType(int iWeaponId) {
    // 1. shotgun
    if (iWeaponId == WP_PUMPSHOTGUN || iWeaponId == WP_SHOTGUN_CHROME || iWeaponId == WP_AUTOSHOTGUN || iWeaponId == WP_SHOTGUN_SPAS)
        return WPTYPE_SHELLS;
    // 2. melee
    if (iWeaponId == WP_MELEE)
        return WPTYPE_MELEE;
    // 3. rifles / snipers / pistols (per shot accuracy)
    if (iWeaponId == WP_PISTOL || iWeaponId == WP_PISTOL_MAGNUM || iWeaponId == WP_SMG || iWeaponId == WP_SMG_SILENCED || iWeaponId == WP_SMG_MP5 || iWeaponId == WP_HUNTING_RIFLE || iWeaponId == WP_SNIPER_MILITARY || iWeaponId == WP_RIFLE || iWeaponId == WP_RIFLE_DESERT || iWeaponId == WP_RIFLE_AK47 || iWeaponId == WP_RIFLE_SG552 || iWeaponId == WP_SNIPER_AWP || iWeaponId == WP_SNIPER_SCOUT || iWeaponId == WP_MACHINEGUN)
        return WPTYPE_BULLETS;
    return WPTYPE_NONE;
}

// get 1v1 survivor player
stock int GetCurrentSurvivor() {
    // assuming only 1, just get the first one
    for (int i = 1; i <= MaxClients; i++) {
        if (IsSurvivor(i)) {
            return i;
        }
    }
    return -1;
}

// clear all stats for client
stock void ClearClientSkeetStats(int iClient) {
    g_iGotKills         [iClient] = 0;
    g_iGotCommon        [iClient] = 0;
    g_iDidDamage        [iClient] = 0;
    g_iDidDamageAll     [iClient] = 0;
    g_iDidDamageWitch   [iClient] = 0;
    g_iDidDamageTank    [iClient] = 0;

    g_iShotsFired       [iClient] = 0;
    g_iPelletsFired     [iClient] = 0;
    g_iShotsHit         [iClient] = 0;
    g_iPelletsHit       [iClient] = 0;
    g_iMeleesFired      [iClient] = 0;
    g_iMeleesHit        [iClient] = 0;
    g_iDeadStops        [iClient] = 0;
    g_iHuntSkeets       [iClient] = 0;
    g_iHuntSkeetsInj    [iClient] = 0;
    g_iHuntHeadShots    [iClient] = 0;

    g_fPreviousShot     [iClient] = 0.0;
    g_iPreviousShotType [iClient] = 0;
    g_bCurrentShotHit   [iClient] = 0;
    g_iCurrentShotDmg   [iClient] = 0;

    g_bIsPouncing       [iClient] = false;
    g_bIsHurt           [iClient] = false;
    g_iDmgDuringPounce  [iClient] = 0;
}

stock bool IsClientAndInGame(int iClient) {
    return (iClient > 0 && iClient <= MaxClients && IsClientInGame(iClient));
}

stock bool IsSurvivor(int iClient) {
    return IsClientAndInGame(iClient) && GetClientTeam(iClient) == TEAM_SURVIVOR;
}

stock bool IsInfected(int iClient) {
    return IsClientAndInGame(iClient) && GetClientTeam(iClient) == TEAM_INFECTED;
}

stock bool IsWitch(int iEntity) {
    if (iEntity > 0 && IsValidEntity(iEntity) && IsValidEdict(iEntity)) {
        char szClassName[64];
        GetEdictClassname(iEntity, szClassName, sizeof(szClassName));
        return strcmp(szClassName, "witch") == 0;
    }
    return false;
}

stock bool IsCommonInfected(int iEntity) {
    if (iEntity > 0 && IsValidEntity(iEntity) && IsValidEdict(iEntity)) {
        char szClassName[64];
        GetEdictClassname(iEntity, szClassName, sizeof(szClassName));
        return strcmp(szClassName, "infected") == 0;
    }
    return false;
}

stock bool HunterShovingIsBlocked() {
    if (!g_bNoHunterM2)
        return false;
    static ConVar cv;
    if (cv == null)
        cv = FindConVar("l4d2_no_hunter_m2");
    static int i;
    i = cv.IntValue;
    return i > 0;
}